<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/%E7%AC%94%E8%AE%B0.png">
  <link rel="icon" type="image/png" href="/img/%E7%AC%94%E8%AE%B0.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2e294e">
  <meta name="description" content="">
  <meta name="author" content="Su ZhenWei">
  <meta name="keywords" content="">
  <title>Java系列-虚拟机 - Szw&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/9.18.1/styles/github-gist.min.css" />


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_fmb4a04yx8h.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_ijqayz9ro8k.css">




<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Szw's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">
              <i class="iconfont icon-home-fill"></i>
              首页</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">
              <i class="iconfont icon-archive-fill"></i>
              归档</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">
              <i class="iconfont icon-category-fill"></i>
              分类</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">
              <i class="iconfont icon-tags-fill"></i>
              标签</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">
              <i class="iconfont icon-user-fill"></i>
              关于</a>
          </li>
        
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/%E6%96%87%E7%AB%A0.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <div class="mt-3 post-meta">
                  <i class="iconfont icon-date-fill" aria-hidden="true"></i>
                  <time datetime="2020-05-09 11:42">
                    星期六, 五月 9日 2020, 11:42 中午
                  </time>
                </div>
              

              <div class="mt-1">
                
                  
                  <span class="post-meta mr-2">
                    <i class="iconfont icon-chart"></i>
                    6.9k 字
                  </span>
                

                
                  
                  <span class="post-meta mr-2">
                      <i class="iconfont icon-clock-fill"></i>
                    
                    
                    73
                     分钟
                  </span>
                

                
              </div>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <p><em>本文大部分内容来自周志明-深入理解Java虚拟机，如想深入了解，请看原书</em></p>
<p><a href="https://www.cnblogs.com/shen-qian/p/11277085.html" target="_blank" rel="noopener">https://www.cnblogs.com/shen-qian/p/11277085.html</a></p>
<h3 id="一、运行时数据区域"><a href="#一、运行时数据区域" class="headerlink" title="一、运行时数据区域"></a>一、运行时数据区域</h3><p><img src="/img/Java/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png" srcset="/img/loading.gif" alt="运行时数据区域"></p>
<h4 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h4><p>用来记录当前线程正在执行的虚拟机字节码指令的地址，如果当前线程执行是本地方法栈则程序计数器为空。</p>
<p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间来实现的，所以为了线程切换之后能恢复到原来的执行位置，每个线程必须有自己独立的程序计数器。</p>
<h4 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2. 虚拟机栈"></a>2. 虚拟机栈</h4><p>每个 Java 方法在执行的同时会创建一个栈帧，用于存储局部变量表、操作数栈、常量池引用、动态链接等信息。每一个方法从调用到执行完毕的过程，都对应着一个栈帧在Java虚拟机栈中入栈和出栈的过程。</p>
<p>可以通过-Xss这个虚拟机参数来指定每个线程的栈内存大小，而在JDK 1.5以后默认为1M：</p>
<pre><code class="hljs java">java -Xss2M</code></pre>

<p>栈可能会遇到以下两种异常</p>
<ul>
<li><p>当线程请求的栈深度大于虚拟机所允许的最大深度，会抛出StackOverflowError异常</p>
<p><em>由于单个线程的栈内存太大导致的</em></p>
</li>
<li><p>栈进行动态扩展时如果无法申请到足够内存，会抛出OutOfMemoryError异常</p>
<p><em>由于线程数太多导致的</em></p>
</li>
</ul>
<h4 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h4><p>本地方法栈与虚拟机栈类似，它们之间的区别仅是本地方法栈为本地方法(Native)服务。</p>
<h4 id="4-Java堆"><a href="#4-Java堆" class="headerlink" title="4. Java堆"></a>4. Java堆</h4><p>Java堆是所有线程共享的一块内存区域，用来存放对象实例，所有的对象实例都在堆里分配内存，同时也是垃圾收集的主要区域。</p>
<p>现代的垃圾收集器基本都是采用分代收集算法，所以可以将堆分成两块：</p>
<ul>
<li>新生代</li>
<li>老年代</li>
</ul>
<p>Java堆可以处于物理不连续的内存空间，只要逻辑上连续即可，并且可以动态扩展内存，扩展失败会抛出OutOfMemoryError异常。</p>
<p>可以通过 -Xms 和 -Xmx 来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值：</p>
<pre><code class="hljs Java">java -Xms1M -Xmx2M</code></pre>

<h4 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h4><p>与Java堆相同，它也是个各个线程共享的内存区域，用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>方法区同Java堆一样，也不需要物理上的连续的内存，逻辑上连续即可。也可以动态扩展，扩展失败一样会抛出OutOfMemoryError异常。</p>
<p>Hot Spot虚拟机设计团队使用永久代来实现方法区。但是从JDK 1.8开始，为了便于管理方法区，移除永久代并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。</p>
<p><em>从JDK 1.8开始，方法区由元空间和Java堆共同实现。其中元空间存放运行时常量池，位于本地内存。而Java堆存放字符串常量池，位于虚拟机内存。</em></p>
<h4 id="6-运行时常量池"><a href="#6-运行时常量池" class="headerlink" title="6. 运行时常量池"></a>6. 运行时常量池</h4><p>运行时常量池是方法区的一部分。Class 文件中的常量池用于存放编译期生成的字面量和符号引用，会在类加载后被放入这个区域。</p>
<p>除了在编译期生成的常量，在运行期间生成新的常量也会放入常量池中，例如 String 类的 intern()。</p>
<h4 id="7-直接内存"><a href="#7-直接内存" class="headerlink" title="7. 直接内存"></a>7. 直接内存</h4><p>在 JDK 1.4 中新加入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的DirectByteBuffer 对象作为这块内存的引用进行操作。</p>
<p>这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。</p>
<h3 id="二、垃圾收集"><a href="#二、垃圾收集" class="headerlink" title="二、垃圾收集"></a>二、垃圾收集</h3><h4 id="1-判断对象是否可以被回收"><a href="#1-判断对象是否可以被回收" class="headerlink" title="1. 判断对象是否可以被回收"></a>1. 判断对象是否可以被回收</h4><ol>
<li><p>引用计数算法</p>
<p>算法思想：为对象添加一个引用计数器，每当对象新增一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</p>
<p>实现简单，但是会导致循环引用（A中有B，B中有A）的问题：在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。</p>
<p>由于循环引用的问题， Java 虚拟机不使用引用计数算法，而使用可达性分析算法。</p>
</li>
<li><p>可达性分析算法</p>
<p>Java 虚拟机使用该算法来判断对象是否可被回收</p>
<p>算法思想：通过一系列称之为 GC Roots 的对象为起始点进行搜索，搜索走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连时（也就是对象到 GC Roots 不可达），则证明该对象不可用。</p>
<p>可达的对象都是存活的，不可达的对象可被回收。</p>
<p><img src="/img/Java/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.png" srcset="/img/loading.gif" alt="可达性分析算法.png"></p>
</li>
</ol>
<p>   可作为 GC Roots 的对象一般包含以下内容：</p>
<ul>
<li>虚拟机栈中局部变量表中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
<li>本地方法栈中 JNI 中引用的对象</li>
</ul>
<h4 id="2-引用类型"><a href="#2-引用类型" class="headerlink" title="2. 引用类型"></a>2. 引用类型</h4><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否可被回收都与“引用”有关。</p>
<p>JDK 1.2 之后对引用的概念进行了扩充，分为以下四种，这四种引用强度依次减弱：</p>
<ol>
<li><p>强引用 (Strong Reference)</p>
<p>通过 new 关键字创建对象的方式属于是创建强引用</p>
<pre><code class="hljs Java">Object obj = <span class="hljs-keyword">new</span> Object();</code></pre>

<p><strong>被强引用关联的对象不会被回收</strong></p>
</li>
<li><p>软引用 (SoftReference)</p>
<p>使用 SoftReference 类来创建软引用</p>
<pre><code class="hljs Java">Object obj = <span class="hljs-keyword">new</span> Object();
SoftReference&lt;Object&gt; sf = <span class="hljs-keyword">new</span> SoftReference&lt;Object&gt;(obj);
obj = <span class="hljs-keyword">null</span>;  <span class="hljs-comment">// 使对象只被软引用关联</span></code></pre>

<p><strong>被软引用关联的对象只有在内存不够的情况下才会被回收</strong></p>
</li>
<li><p>弱引用 (WeakReference)</p>
<p>使用 WeakReference 类来创建弱引用</p>
<pre><code class="hljs Java">Object obj = <span class="hljs-keyword">new</span> Object();
WeakReference&lt;Object&gt; wf = <span class="hljs-keyword">new</span> WeakReference&lt;Object&gt;(obj);
obj = <span class="hljs-keyword">null</span>;</code></pre>

<p><strong>被弱引用关联的对象只能存活到下一次垃圾回收发生之前</strong></p>
</li>
<li><p>虚引用 (PhantomReference)</p>
<p>使用 PhantomReference 来创建虚引用</p>
<pre><code class="hljs Java">Object obj = <span class="hljs-keyword">new</span> Object();
PhantomReference&lt;Object&gt; pf = <span class="hljs-keyword">new</span> PhantomReference&lt;Object&gt;(obj, <span class="hljs-keyword">null</span>);
obj = <span class="hljs-keyword">null</span>;</code></pre>

<p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，完全不会对其生存时间造成影响，也无法通过虚引用来得到一个对象实例</p>
<p><strong>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知</strong></p>
</li>
</ol>
<h4 id="3-标记过程—两次标记"><a href="#3-标记过程—两次标记" class="headerlink" title="3. 标记过程—两次标记"></a>3. 标记过程—两次标记</h4><p>要真正宣告一个对象死亡，至少要经历<strong>两次标记</strong>过程：</p>
<ol>
<li>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选。筛选的条件：此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它，但并会等待它运行结束。</li>
<li>稍后 GC 将会对F-Queue进行第二次小规模标记，如果对象在 finalize() 方法中重新与引用链上的任意一个对象建立了关联，那么在第二次标记中它将被移除即将回收的集合。否则这个对象就会被真正的回收。</li>
</ol>
<h4 id="4-垃圾收集算法"><a href="#4-垃圾收集算法" class="headerlink" title="4. 垃圾收集算法"></a>4. 垃圾收集算法</h4><p><em>以下图片来源：<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md</a></em></p>
<ol>
<li>标记—清除算法</li>
</ol>
<p>   <img src="/img/Java/%E6%A0%87%E8%AE%B0%E2%80%94%E6%B8%85%E9%99%A4.png" srcset="/img/loading.gif" alt="标记—清除"></p>
<p>   算法分为“<strong>标记</strong>”和“<strong>清除</strong>”两个阶段：</p>
<ul>
<li><p>标记过程：首先检查每个对象是否为存活对象，如果是存活对象，则会在对象头部打上标记。</p>
<p><em>标记过程与上一节所说的相同，会有两次标记</em></p>
</li>
<li><p>清除阶段：会进行对象回收并取消标志位。同时，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。</p>
<p>在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于<br>size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。</p>
<p>缺点：</p>
</li>
</ul>
<ol>
<li><p>效率问题：标记和清除两个过程的效率都不高</p>
</li>
<li><p>空间问题：标记清除之后会产生大量不连续的内存碎片</p>
<p><em>空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</em></p>
</li>
</ol>
<ol start="2">
<li><p>标记—整理算法</p>
<p><img src="/img/Java/%E6%A0%87%E8%AE%B0%E2%80%94%E6%95%B4%E7%90%86.png" srcset="/img/loading.gif" alt="标记—整理"></p>
<p><strong>根据老年代的特点</strong>，提出了标记—整理算法</p>
<p>算法分为“<strong>标记</strong>”和“<strong>整理</strong>”两个阶段：</p>
<ul>
<li>标记过程：与标记—清除算法相同。</li>
<li>整理过程：让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</li>
</ul>
<p>优点：</p>
<ol>
<li>解决了空间问题：由于整理阶段，所以不会产生内存碎片</li>
</ol>
<p>缺点：</p>
<ol>
<li>效率问题：需要移动大量对象，相比于标记—清除，处理效率更低</li>
</ol>
</li>
<li><p>复制算法</p>
<p><img src="/img/Java/%E5%A4%8D%E5%88%B6.png" srcset="/img/loading.gif" alt="复制"></p>
<p><strong>复制算法一般用来回收新生代</strong>。</p>
<p>算法流程：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p><em>书中没有明确指出，不过我认为复制算法应是先标记后复制，再清理。</em></p>
<p>目前商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 <strong>Eden</strong> 空间和两块较小的 <strong>Survivor</strong>  空间。每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块  Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。</p>
<p>HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1。</p>
<p>如果 Survivor 不够用了，比如：某次回收有多于10%的对象存活。此时需要依赖于老年代进行<strong>空间分配担保</strong>(通过借用老年代的空间存储放不下的对象)。</p>
<p>优点：</p>
<ol>
<li>解决了效率问题</li>
</ol>
<p>缺点：</p>
<ol>
<li>空间问题：需要一部分内存用于存放存活的对象</li>
</ol>
</li>
<li><p>分代收集算法</p>
<p>目前商业虚拟机的垃圾收集都采用<strong>分代收集算法</strong>。</p>
<p>算法思想：根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p>
<ol>
<li><strong>新生代-复制算法</strong>：每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。</li>
<li><strong>老年代-标记—清除算法或者标记—整理算法</strong>：老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记—清除或者标记—整理算法来进行回收。</li>
</ol>
</li>
</ol>
<h4 id="5-垃圾收集器"><a href="#5-垃圾收集器" class="headerlink" title="5. 垃圾收集器"></a>5. 垃圾收集器</h4><p><img src="/img/Java/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" srcset="/img/loading.gif" alt="垃圾收集器"></p>
<p>上图展示了7种不同分代的收集器，连线说明它们可以搭配使用。</p>
<blockquote>
<p>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</p>
</blockquote>
<blockquote>
<p>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序。而并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</p>
</blockquote>
<blockquote>
<p>Client 模式和Server 模式：前者在客户端环境中减少启动时间而优化，比较适合桌面程序；后者在服务器环境中最大化程序执行速度而设计，适合做服务器程序。HotSpot 虚拟机在默认情况下32位的是client模式；64位的是server模式(可以更改配置文件换用不同的模式)。</p>
</blockquote>
<ol>
<li><p>Serial 收集器</p>
<p><img src="/img/Java/Serial.png" srcset="/img/loading.gif" alt="Serial"></p>
<p><strong>特点：</strong></p>
<ol>
<li><p>单线程：只会使用一个线程完成垃圾收集工作，并且在进行垃圾收集时，必须暂停其他所有的工作线程。</p>
</li>
<li><p>复制算法，并且用于新生代</p>
</li>
<li><p>Client 模式下的默认新生代收集器</p>
</li>
<li><p>能和CMS 收集器配合工作</p>
</li>
</ol>
<p><strong>优点：</strong></p>
<ol>
<li>简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此有着最高的单线程收集效率。</li>
</ol>
</li>
<li><p>ParNew 收集器</p>
<p><img src="/img/Java/ParNew.png" srcset="/img/loading.gif" alt="ParNew"></p>
<p><strong>特点：</strong></p>
<ol>
<li><p>多线程：使用多个线程完成垃圾收集工作，并且在进行垃圾收集时，必须暂停其他所有的工作线程。</p>
</li>
<li><p>复制算法，并且用于新生代</p>
</li>
<li><p>Server 模式下默认的新生代收集器：因为除了Serial 收集器，只有它能与 CMS 收集器配合使用。</p>
</li>
<li><p>能和 CMS 收集器配合工作</p>
</li>
</ol>
<p>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程之外均和 Serial 收集器相同。</p>
</li>
<li><p>Parallel Scavenge 收集器</p>
<p><strong>特点：</strong></p>
<ol>
<li>多线程</li>
<li>复制算法，并且用于新生代</li>
<li>Parallel Scavenge 收集器的目标是达到一个<strong>可控制的吞吐量</strong>。吞吐量就是 CPU 用于运行用户程序的时间占总时间的比值，即：吞吐量 = 运行用户代码时间 / (运行用户代码时间  + 垃圾回收时间)</li>
</ol>
<p><strong>优点：</strong></p>
<ol>
<li>停顿时间越短，越适合需要与用户交互的程序，良好的响应速度能提升用户体验。</li>
<li>高吞吐量可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。</li>
</ol>
<p>Parallel Scavenge 收集器也经常称为“吞吐量优先”收集器。</p>
<p>Parallel Scavenge收集器有一个参数：</p>
<pre><code class="hljs Java">-XX:+UseAdaptiveSizePolicy</code></pre>

<p>这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小、Eden与Survivor区的比例、晋升老年代对象年龄等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为 <strong>GC 自适应的调节策略</strong>。</p>
</li>
<li><p>Serial Old 收集器</p>
<p><img src="/img/Java/SerialOld.png" srcset="/img/loading.gif" alt="Serial Old"></p>
<p><strong>特点：</strong></p>
<ol>
<li>单线程：只会使用一个线程完成垃圾收集工作，并且在进行垃圾收集时，必须暂停其他所有的工作线程。</li>
<li>标记—整理算法，并且用于老年代</li>
<li>用于Client 模式，但在Server 模式下有两个特点：<ol>
<li>在 JDK 1.5 以及之前版本，与 Parallel Scavenge 收集器搭配使用。</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li>
</ol>
</li>
</ol>
</li>
<li><p>Parallel Old 收集器</p>
<p><img src="/img/Java/ParallelOld.png" srcset="/img/loading.gif" alt="Parallel Old"></p>
<p><strong>特点：</strong></p>
<ol>
<li>多线程</li>
<li>标记—整理算法，并且用于老年代</li>
<li>Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本。</li>
</ol>
<p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p>
</li>
<li><p>CMS 收集器</p>
<p><img src="/img/Java/CMS.png" srcset="/img/loading.gif" alt="CMS"></p>
<p>CMS 收集器是一种以获取<strong>最短回收停顿时间</strong>为目标的收集器。</p>
<p>CMS收集器是基于标记一清除算法实现的，整个过程分为4个步骤：</p>
<ol>
<li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，<strong>需要停顿</strong>。</li>
<li>并发标记：进行GC Roots Tracing的过程，它在整个回收过程中耗时最长，不需要停顿。</li>
<li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，<strong>需要停顿</strong>。</li>
<li>并发清除：进行垃圾回收，不需要停顿。</li>
</ol>
<p><strong>优点：</strong></p>
<ol>
<li>并发收集</li>
<li>低停顿</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li><p>对CPU资源非常敏感</p>
<p>在并发阶段虽然不会停顿，但是因为占用一部分线程资源，导致吞吐量降低。也就是说，低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</p>
</li>
<li><p>无法处理浮动垃圾，可能出现 Concurrent Mode  Failure 而导致另一次Full GC 发生</p>
<p>浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS  收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode  Failure，这时虚拟机将临时启用 Serial Old 收集器来替代 CMS 收集器。</p>
</li>
<li><p>标记 - 清除算法导致的空间碎片</p>
<p>由于标记 - 清除算法导致的空间碎片，而出现老年代空间剩余。但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</p>
</li>
</ol>
</li>
<li><p>G1 收集器</p>
<p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p>
<p>在 G1 之前的其他收集器进行收集的范围都是整个新生代或者老年代。</p>
<p><img src="/img/Java/%E4%BC%A0%E7%BB%9F%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" alt="传统结构"></p>
<p>而G1 将整个Java堆划分为多个大小相等的独立区域 (Region)，新生代和老年代都是一部分Region (不需要连续) 的集合。</p>
<p><img src="/img/Java/G1.png" srcset="/img/loading.gif" alt="G1"></p>
<p>通过引入 Region  的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的  Region。</p>
<p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p>
<p><img src="/img/Java/G1%E6%94%B6%E9%9B%86%E5%99%A8.png" srcset="/img/loading.gif" alt="G1收集器"></p>
<p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p>
<ol>
<li>初始标记：初始标记仅仅只是标记一下GC Roots 能直接关联到的对象，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。</li>
<li>并发标记：并发标记从GC Roots 开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。</li>
<li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的  Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered  Set 中。这阶段需要停顿线程，但是可并行执行。</li>
<li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li>
</ol>
<p><strong>特点：</strong></p>
<ol>
<li>并行与并发：G1 能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短 Stop-The-WorId 停顿的时间。当其他收集器需要停顿 Java 线程而执行GC动作，G1收集器却仍然可以通过并发的方式让 Java 程序继续执行。</li>
<li>分代收集：G1 可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。</li>
<li>空间整合：整体来看是基于标记—整理算法实现的收集器，从局部 (两个 Region 之间)上来看是基于复制算法实现的，这意味着运行期间不会产生内存空间碎片。</li>
<li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集 (GC) 上的时间不得超过 N 毫秒。</li>
</ol>
</li>
<li><p>总结：</p>
<p>用于新生代的垃圾收集器：</p>
<p>以下均使用复制算法</p>
<ol>
<li>Serial 收集器</li>
<li>ParNew 收集器</li>
<li>Parallel Scavenge 收集器</li>
</ol>
<p>用于老年代的垃圾收集器：</p>
<ol>
<li>Serial Old 收集器：标记—整理算法</li>
<li>Parallel Old 收集器：标记—整理算法</li>
<li>CMS 收集器：标记—清除算法</li>
</ol>
<p>特殊的垃圾收集器：</p>
<ol>
<li>G1 收集器：<ol>
<li>整体看是基于标记—整理算法</li>
<li>局部看是基于复制算法实现</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="三、内存分配与回收策略"><a href="#三、内存分配与回收策略" class="headerlink" title="三、内存分配与回收策略"></a>三、内存分配与回收策略</h3><h4 id="1-Minor-GC和-Full-GC"><a href="#1-Minor-GC和-Full-GC" class="headerlink" title="1. Minor GC和 Full GC"></a>1. Minor GC和 Full GC</h4><ul>
<li>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li>
<li>Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</li>
</ul>
<h4 id="2-内存分配策略"><a href="#2-内存分配策略" class="headerlink" title="2. 内存分配策略"></a>2. 内存分配策略</h4><ol>
<li><p>对象优先在 Eden 分配</p>
<p>大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间分配时，虚拟机会发起一次Minor GC。</p>
</li>
<li><p>大对象直接进入老年代</p>
<p>大对象是指需要连续内存空间的Java对象，最典型的大对象是那种很长的字符串以及数组。</p>
<p>经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间分配给大对象。</p>
<p>虚拟机提供了一个参数：</p>
<p>大于这个值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</p>
<pre><code class="hljs Java">-XX:PretenureSizeThreshold</code></pre>
</li>
<li><p>长期存活的对象进入老年代</p>
</li>
</ol>
<p>   为对象定义年龄计数器，对象在 Eden 出生并每经过一次 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄(默认为15岁)则移动到老年代中。</p>
<p>   虚拟机提供了一个参数：</p>
<p>   对象晋升老年代的年龄阈值，用来定义年龄的阈值。</p>
   <pre><code class="hljs Java">-XX:MaxTenuringThreshold</code></pre>

<ol start="4">
<li><p>动态对象年龄判定</p>
<p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor<br>中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p>
</li>
<li><p>空间分配担保</p>
<p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</p>
<p>如果不成立的话虚拟机会查看  HandlePromotionFailure  的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次  Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。</p>
</li>
</ol>
<h4 id="3-总结-Full-GC的触发条件"><a href="#3-总结-Full-GC的触发条件" class="headerlink" title="3. 总结 Full GC的触发条件"></a>3. 总结 Full GC的触发条件</h4><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。</p>
<p>而 Full GC 则相对复杂，有以下条件：</p>
<ol>
<li><p>调用 System.gc()</p>
<p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p>
</li>
<li><p>老年代空间不足</p>
<p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p>
<p>为了避免以上原因引起的  Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn  虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold  调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p>
</li>
<li><p>空间分配担保失败</p>
<p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。</p>
</li>
<li><p>JDK 1.7 及以前的永久代空间不足</p>
<p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p>
<p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p>
<p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p>
</li>
<li><p>Concurrent Mode Failure</p>
<p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足 (可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足)，便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p>
</li>
</ol>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Java/">Java</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java/">Java</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/05/23/%E9%A1%B9%E7%9B%AE/B2C%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99/index/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">项目系列-B2C电商网站</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/05/08/Java/Java-%E5%B9%B6%E5%8F%91/index/">
                        <span class="hidden-mobile">Java系列-并发</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>






<!-- Plugins -->



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Java系列-虚拟机&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
      icon: "§"
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>





  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script>
      !function (e, t, a) {
        function r() {
          for (var e = 0; e < s.length; e++) s[e].alpha <= 0 ? (t.body.removeChild(s[e].el), s.splice(e, 1)) : (s[e].y--, s[e].scale += .004, s[e].alpha -= .013, s[e].el.style.cssText = "left:" + s[e].x + "px;top:" + s[e].y + "px;opacity:" + s[e].alpha + ";transform:scale(" + s[e].scale + "," + s[e].scale + ") rotate(45deg);background:" + s[e].color + ";z-index:99999");
          requestAnimationFrame(r)
        }

        function n() {
          var t = "function" == typeof e.onclick && e.onclick;
          e.onclick = function (e) {
            t && t(), o(e)
          }
        }

        function o(e) {
          var a = t.createElement("div");
          a.className = "heart", s.push({
            el: a,
            x: e.clientX - 5,
            y: e.clientY - 5,
            scale: 1,
            alpha: 1,
            color: c()
          }), t.body.appendChild(a)
        }

        function i(e) {
          var a = t.createElement("style");
          a.type = "text/css";
          try {
            a.appendChild(t.createTextNode(e))
          } catch (t) {
            a.styleSheet.cssText = e
          }
          t.getElementsByTagName("head")[0].appendChild(a)
        }

        function c() {
          return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
        }

        var s = [];
        e.requestAnimationFrame = e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) {
          setTimeout(e, 1e3 / 60)
        }, i(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"), n(), r()
      }(window, document);
    </script>
  












</body>
</html>
